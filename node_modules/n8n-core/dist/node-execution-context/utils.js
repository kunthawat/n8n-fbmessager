"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateValueAgainstSchema = void 0;
exports.cleanupParameterData = cleanupParameterData;
exports.ensureType = ensureType;
exports.getAdditionalKeys = getAdditionalKeys;
const luxon_1 = require("luxon");
const n8n_workflow_1 = require("n8n-workflow");
const Constants_1 = require("../Constants");
const ExecutionMetadata_1 = require("../ExecutionMetadata");
const Secrets_1 = require("../Secrets");
function cleanupParameterData(inputData) {
    if (typeof inputData !== 'object' || inputData === null) {
        return;
    }
    if (Array.isArray(inputData)) {
        inputData.forEach((value) => cleanupParameterData(value));
        return;
    }
    if (typeof inputData === 'object') {
        Object.keys(inputData).forEach((key) => {
            const value = inputData[key];
            if (typeof value === 'object') {
                if (luxon_1.DateTime.isDateTime(value)) {
                    inputData[key] = value.toString();
                }
                else {
                    cleanupParameterData(value);
                }
            }
        });
    }
}
const validateResourceMapperValue = (parameterName, paramValues, node, skipRequiredCheck = false) => {
    const result = { valid: true, newValue: paramValues };
    const paramNameParts = parameterName.split('.');
    if (paramNameParts.length !== 2) {
        return result;
    }
    const resourceMapperParamName = paramNameParts[0];
    const resourceMapperField = node.parameters[resourceMapperParamName];
    if (!resourceMapperField || !(0, n8n_workflow_1.isResourceMapperValue)(resourceMapperField)) {
        return result;
    }
    const schema = resourceMapperField.schema;
    const paramValueNames = Object.keys(paramValues);
    for (let i = 0; i < paramValueNames.length; i++) {
        const key = paramValueNames[i];
        const resolvedValue = paramValues[key];
        const schemaEntry = schema.find((s) => s.id === key);
        if (!skipRequiredCheck &&
            schemaEntry?.required === true &&
            schemaEntry.type !== 'boolean' &&
            !resolvedValue) {
            return {
                valid: false,
                errorMessage: `The value "${String(key)}" is required but not set`,
                fieldName: key,
            };
        }
        if (schemaEntry?.type) {
            const validationResult = (0, n8n_workflow_1.validateFieldType)(key, resolvedValue, schemaEntry.type, {
                valueOptions: schemaEntry.options,
            });
            if (!validationResult.valid) {
                return { ...validationResult, fieldName: key };
            }
            else {
                paramValues[key] = validationResult.newValue;
            }
        }
    }
    return result;
};
const validateCollection = (node, runIndex, itemIndex, propertyDescription, parameterPath, validationResult) => {
    let nestedDescriptions;
    if (propertyDescription.type === 'fixedCollection') {
        nestedDescriptions = propertyDescription.options.find((entry) => entry.name === parameterPath[1])?.values;
    }
    if (propertyDescription.type === 'collection') {
        nestedDescriptions = propertyDescription.options;
    }
    if (!nestedDescriptions) {
        return validationResult;
    }
    const validationMap = {};
    for (const prop of nestedDescriptions) {
        if (!prop.validateType || prop.ignoreValidationDuringExecution)
            continue;
        validationMap[prop.name] = {
            type: prop.validateType,
            displayName: prop.displayName,
            options: prop.validateType === 'options' ? prop.options : undefined,
        };
    }
    if (!Object.keys(validationMap).length) {
        return validationResult;
    }
    if (validationResult.valid) {
        for (const value of Array.isArray(validationResult.newValue)
            ? validationResult.newValue
            : [validationResult.newValue]) {
            for (const key of Object.keys(value)) {
                if (!validationMap[key])
                    continue;
                const fieldValidationResult = (0, n8n_workflow_1.validateFieldType)(key, value[key], validationMap[key].type, {
                    valueOptions: validationMap[key].options,
                });
                if (!fieldValidationResult.valid) {
                    throw new n8n_workflow_1.ExpressionError(`Invalid input for field '${validationMap[key].displayName}' inside '${propertyDescription.displayName}' in [item ${itemIndex}]`, {
                        description: fieldValidationResult.errorMessage,
                        runIndex,
                        itemIndex,
                        nodeCause: node.name,
                    });
                }
                value[key] = fieldValidationResult.newValue;
            }
        }
    }
    return validationResult;
};
const validateValueAgainstSchema = (node, nodeType, parameterValue, parameterName, runIndex, itemIndex) => {
    const parameterPath = parameterName.split('.');
    const propertyDescription = nodeType.description.properties.find((prop) => parameterPath[0] === prop.name && n8n_workflow_1.NodeHelpers.displayParameter(node.parameters, prop, node));
    if (!propertyDescription) {
        return parameterValue;
    }
    let validationResult = { valid: true, newValue: parameterValue };
    if (parameterPath.length === 1 &&
        propertyDescription.validateType &&
        !propertyDescription.ignoreValidationDuringExecution) {
        validationResult = (0, n8n_workflow_1.validateFieldType)(parameterName, parameterValue, propertyDescription.validateType);
    }
    else if (propertyDescription.type === 'resourceMapper' &&
        parameterPath[1] === 'value' &&
        typeof parameterValue === 'object') {
        validationResult = validateResourceMapperValue(parameterName, parameterValue, node, propertyDescription.typeOptions?.resourceMapper?.mode !== 'add');
    }
    else if (['fixedCollection', 'collection'].includes(propertyDescription.type)) {
        validationResult = validateCollection(node, runIndex, itemIndex, propertyDescription, parameterPath, validationResult);
    }
    if (!validationResult.valid) {
        throw new n8n_workflow_1.ExpressionError(`Invalid input for '${validationResult.fieldName
            ? String(validationResult.fieldName)
            : propertyDescription.displayName}' [item ${itemIndex}]`, {
            description: validationResult.errorMessage,
            runIndex,
            itemIndex,
            nodeCause: node.name,
        });
    }
    return validationResult.newValue;
};
exports.validateValueAgainstSchema = validateValueAgainstSchema;
function ensureType(toType, parameterValue, parameterName, errorOptions) {
    let returnData = parameterValue;
    if (returnData === null) {
        throw new n8n_workflow_1.ExpressionError(`Parameter '${parameterName}' must not be null`, errorOptions);
    }
    if (returnData === undefined) {
        throw new n8n_workflow_1.ExpressionError(`Parameter '${parameterName}' could not be 'undefined'`, errorOptions);
    }
    if (['object', 'array', 'json'].includes(toType)) {
        if (typeof returnData !== 'object') {
            if (typeof returnData === 'string' && returnData.length) {
                try {
                    const parsedValue = JSON.parse(returnData);
                    returnData = parsedValue;
                }
                catch (error) {
                    throw new n8n_workflow_1.ExpressionError(`Parameter '${parameterName}' could not be parsed`, {
                        ...errorOptions,
                        description: error.message,
                    });
                }
            }
            else {
                throw new n8n_workflow_1.ExpressionError(`Parameter '${parameterName}' must be an ${toType}, but we got '${String(parameterValue)}'`, errorOptions);
            }
        }
        else if (toType === 'json') {
            try {
                JSON.stringify(returnData);
            }
            catch (error) {
                throw new n8n_workflow_1.ExpressionError(`Parameter '${parameterName}' is not valid JSON`, {
                    ...errorOptions,
                    description: error.message,
                });
            }
        }
        if (toType === 'array' && !Array.isArray(returnData)) {
            throw new n8n_workflow_1.ExpressionError(`Parameter '${parameterName}' must be an array, but we got object`, errorOptions);
        }
    }
    try {
        if (toType === 'string') {
            if (typeof returnData === 'object') {
                returnData = JSON.stringify(returnData);
            }
            else {
                returnData = String(returnData);
            }
        }
        if (toType === 'number') {
            returnData = Number(returnData);
            if (Number.isNaN(returnData)) {
                throw new n8n_workflow_1.ExpressionError(`Parameter '${parameterName}' must be a number, but we got '${parameterValue}'`, errorOptions);
            }
        }
        if (toType === 'boolean') {
            returnData = Boolean(returnData);
        }
    }
    catch (error) {
        if (error instanceof n8n_workflow_1.ExpressionError)
            throw error;
        throw new n8n_workflow_1.ExpressionError(`Parameter '${parameterName}' could not be converted to ${toType}`, {
            ...errorOptions,
            description: error.message,
        });
    }
    return returnData;
}
function getAdditionalKeys(additionalData, mode, runExecutionData, options) {
    const executionId = additionalData.executionId ?? Constants_1.PLACEHOLDER_EMPTY_EXECUTION_ID;
    const resumeUrl = `${additionalData.webhookWaitingBaseUrl}/${executionId}`;
    const resumeFormUrl = `${additionalData.formWaitingBaseUrl}/${executionId}`;
    return {
        $execution: {
            id: executionId,
            mode: mode === 'manual' ? 'test' : 'production',
            resumeUrl,
            resumeFormUrl,
            customData: runExecutionData
                ? {
                    set(key, value) {
                        try {
                            (0, ExecutionMetadata_1.setWorkflowExecutionMetadata)(runExecutionData, key, value);
                        }
                        catch (e) {
                            if (mode === 'manual') {
                                throw e;
                            }
                            n8n_workflow_1.LoggerProxy.debug(e.message);
                        }
                    },
                    setAll(obj) {
                        try {
                            (0, ExecutionMetadata_1.setAllWorkflowExecutionMetadata)(runExecutionData, obj);
                        }
                        catch (e) {
                            if (mode === 'manual') {
                                throw e;
                            }
                            n8n_workflow_1.LoggerProxy.debug(e.message);
                        }
                    },
                    get(key) {
                        return (0, ExecutionMetadata_1.getWorkflowExecutionMetadata)(runExecutionData, key);
                    },
                    getAll() {
                        return (0, ExecutionMetadata_1.getAllWorkflowExecutionMetadata)(runExecutionData);
                    },
                }
                : undefined,
        },
        $vars: additionalData.variables,
        $secrets: options?.secretsEnabled ? (0, Secrets_1.getSecretsProxy)(additionalData) : undefined,
        $executionId: executionId,
        $resumeWebhookUrl: resumeUrl,
    };
}
//# sourceMappingURL=utils.js.map