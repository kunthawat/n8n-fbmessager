"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NodeExecutionContext = void 0;
const lodash_1 = require("lodash");
const n8n_workflow_1 = require("n8n-workflow");
const typedi_1 = require("typedi");
const Constants_1 = require("../Constants");
const ExtractValue_1 = require("../ExtractValue");
const InstanceSettings_1 = require("../InstanceSettings");
const utils_1 = require("./utils");
class NodeExecutionContext {
    constructor(workflow, node, additionalData, mode, runExecutionData = null, runIndex = 0, connectionInputData = [], executeData) {
        this.workflow = workflow;
        this.node = node;
        this.additionalData = additionalData;
        this.mode = mode;
        this.runExecutionData = runExecutionData;
        this.runIndex = runIndex;
        this.connectionInputData = connectionInputData;
        this.executeData = executeData;
        this.instanceSettings = typedi_1.Container.get(InstanceSettings_1.InstanceSettings);
    }
    get logger() {
        return n8n_workflow_1.LoggerProxy;
    }
    getExecutionId() {
        return this.additionalData.executionId;
    }
    getNode() {
        return (0, n8n_workflow_1.deepCopy)(this.node);
    }
    getWorkflow() {
        const { id, name, active } = this.workflow;
        return { id, name, active };
    }
    getMode() {
        return this.mode;
    }
    getWorkflowStaticData(type) {
        return this.workflow.getStaticData(type, this.node);
    }
    getChildNodes(nodeName) {
        const output = [];
        const nodeNames = this.workflow.getChildNodes(nodeName);
        for (const n of nodeNames) {
            const node = this.workflow.nodes[n];
            output.push({
                name: node.name,
                type: node.type,
                typeVersion: node.typeVersion,
                disabled: node.disabled ?? false,
            });
        }
        return output;
    }
    getParentNodes(nodeName) {
        const output = [];
        const nodeNames = this.workflow.getParentNodes(nodeName);
        for (const n of nodeNames) {
            const node = this.workflow.nodes[n];
            output.push({
                name: node.name,
                type: node.type,
                typeVersion: node.typeVersion,
                disabled: node.disabled ?? false,
            });
        }
        return output;
    }
    getKnownNodeTypes() {
        return this.workflow.nodeTypes.getKnownTypes();
    }
    getRestApiUrl() {
        return this.additionalData.restApiUrl;
    }
    getInstanceBaseUrl() {
        return this.additionalData.instanceBaseUrl;
    }
    getInstanceId() {
        return this.instanceSettings.instanceId;
    }
    getTimezone() {
        return this.workflow.timezone;
    }
    getCredentialsProperties(type) {
        return this.additionalData.credentialsHelper.getCredentialsProperties(type);
    }
    async _getCredentials(type, executeData, connectionInputData, itemIndex) {
        const { workflow, node, additionalData, mode, runExecutionData, runIndex } = this;
        const nodeType = workflow.nodeTypes.getByNameAndVersion(node.type, node.typeVersion);
        const fullAccess = [Constants_1.HTTP_REQUEST_NODE_TYPE, Constants_1.HTTP_REQUEST_TOOL_NODE_TYPE].includes(node.type);
        let nodeCredentialDescription;
        if (!fullAccess) {
            if (nodeType.description.credentials === undefined) {
                throw new n8n_workflow_1.NodeOperationError(node, `Node type "${node.type}" does not have any credentials defined`, { level: 'warning' });
            }
            nodeCredentialDescription = nodeType.description.credentials.find((credentialTypeDescription) => credentialTypeDescription.name === type);
            if (nodeCredentialDescription === undefined) {
                throw new n8n_workflow_1.NodeOperationError(node, `Node type "${node.type}" does not have any credentials of type "${type}" defined`, { level: 'warning' });
            }
            if (!n8n_workflow_1.NodeHelpers.displayParameter(additionalData.currentNodeParameters || node.parameters, nodeCredentialDescription, node, node.parameters)) {
                throw new n8n_workflow_1.NodeOperationError(node, 'Credentials not found');
            }
        }
        if (!fullAccess && !node.credentials?.[type]) {
            if (nodeCredentialDescription?.required === true) {
                if (!node.credentials) {
                    throw new n8n_workflow_1.NodeOperationError(node, 'Node does not have any credentials set', {
                        level: 'warning',
                    });
                }
                if (!node.credentials[type]) {
                    throw new n8n_workflow_1.NodeOperationError(node, `Node does not have any credentials set for "${type}"`, {
                        level: 'warning',
                    });
                }
            }
            else {
                throw new n8n_workflow_1.NodeOperationError(node, 'Node does not require credentials');
            }
        }
        if (fullAccess && !node.credentials?.[type]) {
            throw new n8n_workflow_1.NodeOperationError(node, 'Credentials not found');
        }
        let expressionResolveValues;
        if (connectionInputData && runExecutionData && runIndex !== undefined) {
            expressionResolveValues = {
                connectionInputData,
                itemIndex: itemIndex || 0,
                node,
                runExecutionData,
                runIndex,
                workflow,
            };
        }
        const nodeCredentials = node.credentials
            ? node.credentials[type]
            : {};
        const decryptedDataObject = await additionalData.credentialsHelper.getDecrypted(additionalData, nodeCredentials, type, mode, executeData, false, expressionResolveValues);
        return decryptedDataObject;
    }
    get additionalKeys() {
        return (0, utils_1.getAdditionalKeys)(this.additionalData, this.mode, this.runExecutionData);
    }
    getNodeParameter(parameterName, fallbackValue, options) {
        const itemIndex = 0;
        return this._getNodeParameter(parameterName, itemIndex, fallbackValue, options);
    }
    _getNodeParameter(parameterName, itemIndex, fallbackValue, options) {
        const { workflow, node, mode, runExecutionData, runIndex, connectionInputData, executeData } = this;
        const nodeType = workflow.nodeTypes.getByNameAndVersion(node.type, node.typeVersion);
        const value = (0, lodash_1.get)(node.parameters, parameterName, fallbackValue);
        if (value === undefined) {
            throw new n8n_workflow_1.ApplicationError('Could not get parameter', { extra: { parameterName } });
        }
        if (options?.rawExpressions) {
            return value;
        }
        const { additionalKeys } = this;
        let returnData;
        try {
            returnData = workflow.expression.getParameterValue(value, runExecutionData, runIndex, itemIndex, node.name, connectionInputData, mode, additionalKeys, executeData, false, {}, options?.contextNode?.name);
            (0, utils_1.cleanupParameterData)(returnData);
        }
        catch (e) {
            if (e instanceof n8n_workflow_1.ExpressionError &&
                node.continueOnFail &&
                node.type === 'n8n-nodes-base.set') {
                returnData = [{ name: undefined, value: undefined }];
            }
            else {
                if (e.context)
                    e.context.parameter = parameterName;
                e.cause = value;
                throw e;
            }
        }
        if (options?.extractValue) {
            returnData = (0, ExtractValue_1.extractValue)(returnData, parameterName, node, nodeType, itemIndex);
        }
        if (options?.ensureType) {
            returnData = (0, utils_1.ensureType)(options.ensureType, returnData, parameterName, {
                itemIndex,
                runIndex,
                nodeCause: node.name,
            });
        }
        returnData = (0, utils_1.validateValueAgainstSchema)(node, nodeType, returnData, parameterName, runIndex, itemIndex);
        return returnData;
    }
    evaluateExpression(expression, itemIndex = 0) {
        return this.workflow.expression.resolveSimpleParameterValue(`=${expression}`, {}, this.runExecutionData, this.runIndex, itemIndex, this.node.name, this.connectionInputData, this.mode, this.additionalKeys, this.executeData);
    }
    async prepareOutputData(outputData) {
        return [outputData];
    }
}
exports.NodeExecutionContext = NodeExecutionContext;
//# sourceMappingURL=node-execution-context.js.map