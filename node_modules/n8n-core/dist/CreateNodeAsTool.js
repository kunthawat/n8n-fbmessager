"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createNodeAsTool = createNodeAsTool;
const tools_1 = require("@langchain/core/tools");
const n8n_workflow_1 = require("n8n-workflow");
const zod_1 = require("zod");
class AIParametersParser {
    constructor(options) {
        this.options = options;
        this.runIndex = 0;
    }
    generateZodSchema(placeholder) {
        let schema;
        switch (placeholder.type?.toLowerCase()) {
            case 'string':
                schema = zod_1.z.string();
                break;
            case 'number':
                schema = zod_1.z.number();
                break;
            case 'boolean':
                schema = zod_1.z.boolean();
                break;
            case 'json':
                schema = zod_1.z.record(zod_1.z.any());
                break;
            default:
                schema = zod_1.z.string();
        }
        if (placeholder.description) {
            schema = schema.describe(`${schema.description ?? ''} ${placeholder.description}`.trim());
        }
        if (placeholder.defaultValue !== undefined) {
            schema = schema.default(placeholder.defaultValue);
        }
        return schema;
    }
    traverseNodeParameters(payload, collectedArgs) {
        if (typeof payload === 'string') {
            const fromAICalls = this.extractFromAICalls(payload);
            fromAICalls.forEach((call) => collectedArgs.push(call));
        }
        else if (Array.isArray(payload)) {
            payload.forEach((item) => this.traverseNodeParameters(item, collectedArgs));
        }
        else if (typeof payload === 'object' && payload !== null) {
            Object.values(payload).forEach((value) => this.traverseNodeParameters(value, collectedArgs));
        }
    }
    extractFromAICalls(str) {
        const args = [];
        const pattern = /\$fromAI\s*\(\s*/gi;
        let match;
        while ((match = pattern.exec(str)) !== null) {
            const startIndex = match.index + match[0].length;
            let current = startIndex;
            let inQuotes = false;
            let quoteChar = '';
            let parenthesesCount = 1;
            let argsString = '';
            while (current < str.length && parenthesesCount > 0) {
                const char = str[current];
                if (inQuotes) {
                    if (char === '\\' && current + 1 < str.length) {
                        argsString += char + str[current + 1];
                        current += 2;
                        continue;
                    }
                    if (char === quoteChar) {
                        inQuotes = false;
                        quoteChar = '';
                    }
                    argsString += char;
                }
                else {
                    if (['"', "'", '`'].includes(char)) {
                        inQuotes = true;
                        quoteChar = char;
                    }
                    else if (char === '(') {
                        parenthesesCount++;
                    }
                    else if (char === ')') {
                        parenthesesCount--;
                    }
                    if (parenthesesCount > 0 || char !== ')') {
                        argsString += char;
                    }
                }
                current++;
            }
            if (parenthesesCount === 0) {
                try {
                    const parsedArgs = this.parseArguments(argsString);
                    args.push(parsedArgs);
                }
                catch (error) {
                    throw new n8n_workflow_1.NodeOperationError(this.options.node, `Failed to parse $fromAI arguments: ${argsString}: ${error}`);
                }
            }
            else {
                throw new n8n_workflow_1.NodeOperationError(this.options.node, `Unbalanced parentheses while parsing $fromAI call: ${str.slice(startIndex)}`);
            }
        }
        return args;
    }
    parseArguments(argsString) {
        const args = [];
        let currentArg = '';
        let inQuotes = false;
        let quoteChar = '';
        let escapeNext = false;
        for (let i = 0; i < argsString.length; i++) {
            const char = argsString[i];
            if (escapeNext) {
                currentArg += char;
                escapeNext = false;
                continue;
            }
            if (char === '\\') {
                escapeNext = true;
                continue;
            }
            if (['"', "'", '`'].includes(char)) {
                if (!inQuotes) {
                    inQuotes = true;
                    quoteChar = char;
                    currentArg += char;
                }
                else if (char === quoteChar) {
                    inQuotes = false;
                    quoteChar = '';
                    currentArg += char;
                }
                else {
                    currentArg += char;
                }
                continue;
            }
            if (char === ',' && !inQuotes) {
                args.push(currentArg.trim());
                currentArg = '';
                continue;
            }
            currentArg += char;
        }
        if (currentArg) {
            args.push(currentArg.trim());
        }
        const cleanArgs = args.map((arg) => {
            const trimmed = arg.trim();
            if ((trimmed.startsWith("'") && trimmed.endsWith("'")) ||
                (trimmed.startsWith('`') && trimmed.endsWith('`')) ||
                (trimmed.startsWith('"') && trimmed.endsWith('"'))) {
                return trimmed
                    .slice(1, -1)
                    .replace(/\\'/g, "'")
                    .replace(/\\`/g, '`')
                    .replace(/\\"/g, '"')
                    .replace(/\\\\/g, '\\');
            }
            return trimmed;
        });
        const type = cleanArgs?.[2] || 'string';
        if (!['string', 'number', 'boolean', 'json'].includes(type.toLowerCase())) {
            throw new n8n_workflow_1.NodeOperationError(this.options.node, `Invalid type: ${type}`);
        }
        return {
            key: cleanArgs[0] || '',
            description: cleanArgs[1],
            type: (cleanArgs?.[2] ?? 'string'),
            defaultValue: this.parseDefaultValue(cleanArgs[3]),
        };
    }
    parseDefaultValue(value) {
        if (value === undefined || value === '')
            return undefined;
        const lowerValue = value.toLowerCase();
        if (lowerValue === 'true')
            return true;
        if (lowerValue === 'false')
            return false;
        if (!isNaN(Number(value)))
            return Number(value);
        try {
            return (0, n8n_workflow_1.jsonParse)(value);
        }
        catch {
            return value;
        }
    }
    getDescription(node, nodeParameters) {
        const manualDescription = nodeParameters.toolDescription;
        if (nodeParameters.descriptionType === 'auto') {
            const resource = nodeParameters.resource;
            const operation = nodeParameters.operation;
            let description = node.description.description;
            if (resource) {
                description += `\n Resource: ${resource}`;
            }
            if (operation) {
                description += `\n Operation: ${operation}`;
            }
            return description.trim();
        }
        if (nodeParameters.descriptionType === 'manual') {
            return manualDescription ?? node.description.description;
        }
        return node.description.description;
    }
    createTool() {
        const { node, nodeType } = this.options;
        const collectedArguments = [];
        this.traverseNodeParameters(node.parameters, collectedArguments);
        const nameValidationRegex = /^[a-zA-Z0-9_-]{1,64}$/;
        const keyMap = new Map();
        for (const argument of collectedArguments) {
            if (argument.key.length === 0 || !nameValidationRegex.test(argument.key)) {
                const isEmptyError = 'You must specify a key when using $fromAI()';
                const isInvalidError = `Parameter key \`${argument.key}\` is invalid`;
                const error = new Error(argument.key.length === 0 ? isEmptyError : isInvalidError);
                throw new n8n_workflow_1.NodeOperationError(node, error, {
                    description: 'Invalid parameter key, must be between 1 and 64 characters long and only contain letters, numbers, underscores, and hyphens',
                });
            }
            if (keyMap.has(argument.key)) {
                const existingArg = keyMap.get(argument.key);
                if (existingArg.description !== argument.description ||
                    existingArg.type !== argument.type) {
                    throw new n8n_workflow_1.NodeOperationError(node, `Duplicate key '${argument.key}' found with different description or type`, {
                        description: 'Ensure all $fromAI() calls with the same key have consistent descriptions and types',
                    });
                }
            }
            else {
                keyMap.set(argument.key, argument);
            }
        }
        const uniqueArgsMap = collectedArguments.reduce((map, arg) => {
            map.set(arg.key, arg);
            return map;
        }, new Map());
        const uniqueArguments = Array.from(uniqueArgsMap.values());
        const schemaObj = uniqueArguments.reduce((acc, placeholder) => {
            acc[placeholder.key] = this.generateZodSchema(placeholder);
            return acc;
        }, {});
        const schema = zod_1.z.object(schemaObj).required();
        const description = this.getDescription(nodeType, node.parameters);
        const nodeName = node.name.replace(/ /g, '_');
        const name = nodeName || nodeType.description.name;
        const tool = new tools_1.DynamicStructuredTool({
            name,
            description,
            schema,
            func: async (toolArgs) => {
                const currentRunIndex = this.runIndex++;
                const context = this.options.contextFactory(currentRunIndex, {});
                context.addInputData("ai_tool", [[{ json: toolArgs }]]);
                try {
                    const result = await nodeType.execute?.call(context);
                    const mappedResults = result?.[0]?.flatMap((item) => item.json);
                    context.addOutputData("ai_tool", currentRunIndex, [
                        [{ json: { response: mappedResults } }],
                    ]);
                    return JSON.stringify(mappedResults);
                }
                catch (error) {
                    const nodeError = new n8n_workflow_1.NodeOperationError(this.options.node, error);
                    context.addOutputData("ai_tool", currentRunIndex, nodeError);
                    return 'Error during node execution: ' + nodeError.description;
                }
            },
        });
        return tool;
    }
}
function createNodeAsTool(options) {
    const parser = new AIParametersParser(options);
    return { response: parser.createTool() };
}
//# sourceMappingURL=CreateNodeAsTool.js.map