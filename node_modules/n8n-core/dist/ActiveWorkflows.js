"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ActiveWorkflows = void 0;
const n8n_workflow_1 = require("n8n-workflow");
const typedi_1 = require("typedi");
const ScheduledTaskManager_1 = require("./ScheduledTaskManager");
let ActiveWorkflows = class ActiveWorkflows {
    constructor(scheduledTaskManager) {
        this.scheduledTaskManager = scheduledTaskManager;
        this.activeWorkflows = {};
    }
    isActive(workflowId) {
        return this.activeWorkflows.hasOwnProperty(workflowId);
    }
    allActiveWorkflows() {
        return Object.keys(this.activeWorkflows);
    }
    get(workflowId) {
        return this.activeWorkflows[workflowId];
    }
    async add(workflowId, workflow, additionalData, mode, activation, getTriggerFunctions, getPollFunctions) {
        this.activeWorkflows[workflowId] = {};
        const triggerNodes = workflow.getTriggerNodes();
        let triggerResponse;
        this.activeWorkflows[workflowId].triggerResponses = [];
        for (const triggerNode of triggerNodes) {
            try {
                triggerResponse = await workflow.runTrigger(triggerNode, getTriggerFunctions, additionalData, mode, activation);
                if (triggerResponse !== undefined) {
                    this.activeWorkflows[workflowId].triggerResponses.push(triggerResponse);
                }
            }
            catch (e) {
                const error = e instanceof Error ? e : new Error(`${e}`);
                throw new n8n_workflow_1.WorkflowActivationError(`There was a problem activating the workflow: "${error.message}"`, { cause: error, node: triggerNode });
            }
        }
        const pollingNodes = workflow.getPollNodes();
        if (pollingNodes.length === 0)
            return;
        for (const pollNode of pollingNodes) {
            try {
                await this.activatePolling(pollNode, workflow, additionalData, getPollFunctions, mode, activation);
            }
            catch (e) {
                const error = e instanceof Error ? e : new Error(`${e}`);
                throw new n8n_workflow_1.WorkflowActivationError(`There was a problem activating the workflow: "${error.message}"`, { cause: error, node: pollNode });
            }
        }
    }
    async activatePolling(node, workflow, additionalData, getPollFunctions, mode, activation) {
        const pollFunctions = getPollFunctions(workflow, node, additionalData, mode, activation);
        const pollTimes = pollFunctions.getNodeParameter('pollTimes');
        const cronTimes = (pollTimes.item || []).map(n8n_workflow_1.toCronExpression);
        const executeTrigger = async (testingTrigger = false) => {
            n8n_workflow_1.LoggerProxy.debug(`Polling trigger initiated for workflow "${workflow.name}"`, {
                workflowName: workflow.name,
                workflowId: workflow.id,
            });
            try {
                const pollResponse = await workflow.runPoll(node, pollFunctions);
                if (pollResponse !== null) {
                    pollFunctions.__emit(pollResponse);
                }
            }
            catch (error) {
                if (testingTrigger) {
                    throw error;
                }
                pollFunctions.__emitError(error);
            }
        };
        await executeTrigger(true);
        for (const cronTime of cronTimes) {
            const cronTimeParts = cronTime.split(' ');
            if (cronTimeParts.length > 0 && cronTimeParts[0].includes('*')) {
                throw new n8n_workflow_1.ApplicationError('The polling interval is too short. It has to be at least a minute.');
            }
            this.scheduledTaskManager.registerCron(workflow, cronTime, executeTrigger);
        }
    }
    async remove(workflowId) {
        if (!this.isActive(workflowId)) {
            n8n_workflow_1.LoggerProxy.warn(`Cannot deactivate already inactive workflow ID "${workflowId}"`);
            return false;
        }
        this.scheduledTaskManager.deregisterCrons(workflowId);
        const w = this.activeWorkflows[workflowId];
        for (const r of w.triggerResponses ?? []) {
            await this.closeTrigger(r, workflowId);
        }
        delete this.activeWorkflows[workflowId];
        return true;
    }
    async removeAllTriggerAndPollerBasedWorkflows() {
        for (const workflowId of Object.keys(this.activeWorkflows)) {
            await this.remove(workflowId);
        }
    }
    async closeTrigger(response, workflowId) {
        if (!response.closeFunction)
            return;
        try {
            await response.closeFunction();
        }
        catch (e) {
            if (e instanceof n8n_workflow_1.TriggerCloseError) {
                n8n_workflow_1.LoggerProxy.error(`There was a problem calling "closeFunction" on "${e.node.name}" in workflow "${workflowId}"`);
                n8n_workflow_1.ErrorReporterProxy.error(e, { extra: { workflowId } });
                return;
            }
            const error = e instanceof Error ? e : new Error(`${e}`);
            throw new n8n_workflow_1.WorkflowDeactivationError(`Failed to deactivate trigger of workflow ID "${workflowId}": "${error.message}"`, { cause: error, workflowId });
        }
    }
};
exports.ActiveWorkflows = ActiveWorkflows;
exports.ActiveWorkflows = ActiveWorkflows = __decorate([
    (0, typedi_1.Service)(),
    __metadata("design:paramtypes", [ScheduledTaskManager_1.ScheduledTaskManager])
], ActiveWorkflows);
//# sourceMappingURL=ActiveWorkflows.js.map