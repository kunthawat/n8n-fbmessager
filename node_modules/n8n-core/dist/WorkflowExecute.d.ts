import type { ExecutionBaseError, IConnection, INode, INodeExecutionData, IPinData, IRun, IRunData, Workflow, IRunExecutionData, IWorkflowExecuteAdditionalData, WorkflowExecuteMode, StartNodeData } from 'n8n-workflow';
import PCancelable from 'p-cancelable';
export declare class WorkflowExecute {
    private readonly additionalData;
    private readonly mode;
    private runExecutionData;
    private status;
    private readonly abortController;
    constructor(additionalData: IWorkflowExecuteAdditionalData, mode: WorkflowExecuteMode, runExecutionData?: IRunExecutionData);
    run(workflow: Workflow, startNode?: INode, destinationNode?: string, pinData?: IPinData): PCancelable<IRun>;
    forceInputNodeExecution(workflow: Workflow): boolean;
    runPartialWorkflow(workflow: Workflow, runData: IRunData, startNodes: StartNodeData[], destinationNode?: string, pinData?: IPinData): PCancelable<IRun>;
    runPartialWorkflow2(workflow: Workflow, runData: IRunData, pinData?: IPinData, dirtyNodeNames?: string[], destinationNodeName?: string): PCancelable<IRun>;
    executeHook(hookName: string, parameters: any[]): Promise<void>;
    moveNodeMetadata(): void;
    incomingConnectionIsEmpty(runData: IRunData, inputConnections: IConnection[], runIndex: number): boolean;
    prepareWaitingToExecution(nodeName: string, numberOfConnections: number, runIndex: number): void;
    addNodeToBeExecuted(workflow: Workflow, connectionData: IConnection, outputIndex: number, parentNodeName: string, nodeSuccessData: INodeExecutionData[][], runIndex: number): void;
    processRunExecutionData(workflow: Workflow): PCancelable<IRun>;
    processSuccessExecution(startedAt: Date, workflow: Workflow, executionError?: ExecutionBaseError, closeFunction?: Promise<void>): Promise<IRun>;
    getFullRunData(startedAt: Date): IRun;
    private get isCancelled();
}
